<!--pages/key/key.wxml-->
<view class="page" wx:if="{{type == 'html'}}">
    <view wx:if="{{key == 1}}">
        <view class="content">
            <view class="title">语义化的理解</view>
            <view>HTML语义化是指在用标签构建HTML页面时避免大篇幅地使用无语义的标签。</view>
        </view>
        <view class="content">
            <view class="title">语义化的好处</view>
            <view>
                <text class="num">1)</text>让人更容易阅读，有利于开发和维护，代码更具有可读性，更容易维护
            </view>
            <view>
                <text class="num">2)</text>让搜索引擎更容易读懂，加上爬虫依赖于标签来确定上下文和各个关键字的权重（SEO），语义化有助于爬虫抓取更多的有效信息
            </view>
            <view>
                <text class="num">3)</text>有利于用户阅读，样式文件未加载时页面结构清晰
            </view>
            <view>
                <text class="num">4)</text>有利于屏幕阅读器解析，比如盲人阅读器会根据语义渲染网页
            </view>
        </view>
        <view class="content">
            <view class="title">语义化表现形式-html5新标签</view>
            <view>
                <text class="num">1)</text>header-页眉、footer-页脚、aside-附属信息、nav-导航链接、section、article
            </view>
            <view>
                <text class="num">2)</text>caption-表格标题、thead-表头、tbody-表格内容、tfoot-表尾
            </view>
            <view>
                <text class="num">3)</text>h1~h6，作为标题使用，且重要性递减
            </view>
        </view>
        <view class="content">
            <view class="title">语义化表现形式-html5新标签</view>
            <view>
                <text class="num">1)</text>header-页眉、footer-页脚、aside-附属信息、nav-导航链接、section、article
            </view>
            <view>
                <text class="num">2)</text>caption-表格标题、thead-表头、tbody-表格内容、tfoot-表尾
            </view>
            <view>
                <text class="num">3)</text>h1~h6，作为标题使用，且重要性递减
            </view>
        </view>
    </view>
    <view class="content" wx:if="{{key==2}}">
        <view class="title">px，em，rem区别</view>
        <view>
            <text class="num">1)</text> px 相对长度单位，是相当于显示器的分辨率而言的
        </view>
        <view>
            <text class="num">2)</text>em 相对长度单位，相对父元素的字体大小而言的
        </view>
        <view>
            <text class="num">3)</text>rem 相对长度单位，相对html根元素的字体大小而言的，css3新增元素
        </view>
    </view>
    <view class="content" wx:if="{{key==3}}">
        <view class="title">盒子模型</view>
        <view>通过box-sizing切换，默认为content-box(w3c盒子模型)，border-box时为IE盒子模型</view>
        <view>
            <text class="num">1)</text> IE盒子模型 宽度=内容宽度+padding *2+border *2
        </view>
        <view>
            <text class="num">2)</text>w3c盒子模型 宽度=内容宽度
        </view>
    </view>
    <view class="content" wx:if="{{key==4}}">
        <view class="title">BFC</view>
        <view> 块级格式化上下文，让BFC里面的元素与外面元素隔离，使里外元素的定位不会相互影响。</view>
        <view>触发条件:</view>
        <view>根元素、overflow不为visible、float、 position:absolute或fixed、display:inline-block或table</view>
        <view>应用:</view>
        <view>
            <text class="num">1)</text> 防止垂直方向margin重叠
        </view>
        <view>
            <text class="num">2)</text>不和浮动元素重叠
        </view>
        <view>
            <text class="num">3)</text>清除元素内部浮动
        </view>
    </view>
    <view class="content" wx:if="{{key==5}}">
        <view class="title">target和currentTarget区别</view>
        <view><text class="num">1)</text> target是事件的真正目标</view>
        <view><text class="num">2)</text> currentTarget是事件处理程序注册的元素</view>
    </view>
    <view class="content" wx:if="{{key==6}}">
        <view class="title">document.ready和window.onload区别</view>
        <view>document.ready是dom树加载后执行，而window.onload是整个页面资源加载完后执行，所以document.ready比window.onload先执行</view>
    </view>
    <view class="content" wx:if="{{key==7}}">
        <view class="title">事件流</view>
        <view>DOM2事件流分为三个部分:事件捕获、处于目标、事件冒泡。</view>
        <view><text class="num">1)</text> 事件冒泡是指事件从执行的元素开始往上层遍历执行</view>
        <view><text class="num">2)</text> 事件捕获是指事件从根元素开始从外向里执行</view>
        <view>点击按钮后，事件冒泡的执行顺序是:
            button->body->html->document</view>
        <view>事件捕获的执行顺序则相反:
            document->html->body->button</view>
    </view>
    <view class="content" wx:if="{{key==8}}">
        <view class="title">doctype作用，严格模式和混合模式的区别</view>
        <view>
            !doctype声明位于文档的最前面，在html之前显示。用于告诉浏览器的解析器，用什么文档类型规范来解析文档。
        </view>
        <view> 严格模式默认用浏览器支持的最高版本解析，混合模式以宽松的向后兼容的方式解析，doctype不存在或格式不正确时会让文档以混杂模式呈现</view>
    </view>
    <view class="content" wx:if="{{key==9}}">
        <view class="title">水平垂直居中的实现方式</view>
        <view>
            <view><text class="num">//方法一</text></view>
            <view>display:flex;</view>
            <view>justify-content:center;</view>
            <view>align-items:center;</view>
            <view><text class="num">//方法二</text></view>
            <view>display:table;</view>
            <view>vertical-align:center;</view>
            <view><text class="num">//方法三:适用于已知宽高且父元素定位不为static</text></view>
            <view>postion:absolute;</view>
            <view>width:100px;</view>
            <view>height:100px;</view>
            <view>top:50%;</view>
            <view>left:50%;</view>
            <view>margin:-50px 0 0 -50px;</view>
            <view><text class="num">//方法四</text></view>
            <view>position:absolute;</view>
            <view>top:50%;</view>
            <view>left:50%;</view>
            <view>transform:translateY(-50%) translateX(-50%);</view>
            <view><text class="num">//方法五:适用于行内元素</text></view>
            <view>display:inline-block;</view>
            <view>width:100px;</view>
            <view>height:100px;</view>
            <view>text-align:center;</view>
            <view>line-height:100px;</view>
            <view><text class="num">//方法六:适用于块级元素</text></view>
            <view>display:block;</view>
            <view>height:100px;</view>
            <view>margin:0 auto;</view>
            <view> line-height:100px;</view>
        </view>
    </view>
    <view class="content" wx:if="{{key==10}}">
        <view class="title">回流和重绘区别</view>
        <view>回流：当渲染树中元素尺寸、结构或者某些属性发生变化时，浏览器重新渲染部分或全部页面的情况叫回流。 </view>
        <view>下列元素改变引发回流:</view>
        <view><text class="num">1)</text>getBoundingClientRect()</view>
        <view><text class="num">2)</text>scrollTo()</view>
        <view><text class="num">3)</text>scrollIntoView()或者scrollIntoViewIfneeded</view>
        <view><text class="num">4)</text>clientTop、clientLeft、clientWidth、clientHeight</view>
        <view><text class="num">5)</text>offsetTop、offsetLeft、offsetWidth、offsetHeight</view>
        <view><text class="num">6)</text>scrollTop、scrollLeft、scrollWidth、scrollHeight</view>
        <view><text class="num">7)</text>getComputedStyle()</view>
        <view>重绘：当页面中元素样式变化不会改变它在文档流中的位置时，即不会使元素的几何属性发生变化，浏览器会将新样式赋给它并重新绘制页面(比如color、backgroundColor)</view>
        <view><text class="num">注意：</text>频繁回流和重绘会引起性能问题</view>
        <view>避免方法：</view>
        <view><text class="num">1)</text>减少table布局使用</view>
        <view><text class="num">2)</text>减少css表达式的使用(如calc())</view>
        <view><text class="num">3)</text>减少DOM操作，用documentFragment代替</view>
        <view><text class="num">4)</text>将元素设为display:none;操作结束后把它显示回来，因为display:none不会引发回流重绘</view>
        <view><text class="num">5)</text>避免频繁读取会引发回流重绘的元素，如果需要最好是缓存起来</view>
        <view><text class="num">6)</text>对复杂动画元素使用绝对定位，使它脱离文档流</view>
        <view><text class="num">7)</text>减少使用行内样式</view>

    </view>
    <view class="btn">
        <view bindtap="nextQuestion">下一题</view>
    </view>
</view>
<view class="page" wx:if="{{type == 'js'}}">
    <view wx:if="{{key==0}}">
        <view class="content">
            <view class="title">基本的数据类型介绍，及值类型和引用类型的理解</view>
            <view>在 JS 中共有 8 种基础的数据类型，分别为： Undefined 、 Null 、 Boolean 、 Number 、 String 、 Object 、 Symbol 、 BigInt
            </view>
            <view>其中 Symbol 和 BigInt 是 ES6 新增的数据类型</view>
            <view>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</view>
            <view>BigInt 可以表示任意大小的整数。</view>
        </view>
        <view class="content">
            <view class="title">数据类型的判断</view>
            <view> <text class="num">typeof：</text> 能判断所有值类型，函数。不可对 null、对象、数组进行精确判断，因为都返回 object</view>
            <view> <text class="num">instanceof：</text>
                能判断对象类型，不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。其实现就是顺着原型链去找，如果能找到对应的 Xxxxx.prototype 即为 true 。</view>
            <view>
                <text class="num">Object.prototype.toString.call()：</text>
                所有原始数据类型都是能判断的，还有 Error 对象，Date 对象等。
            </view>
        </view>
    </view>
    <view class="content" wx:if="{{key==1}}">
        <view class="title">setTimeout、setInterval区别</view>
        <view>
            两者都是定时器，设定一个150ms后执行的定时器不代表150ms后定时器会执行，它表示代码在150ms内会被加入队列，如果这个时间点队列没有其他逻辑在执行，表面上看代码在精确时间执行了。在队列中有其他逻辑时，代码等待时间会超过150ms
        </view>
        <view>setTimeout 只执行一次</view>
        <view>setInterval 执行多次，属于重复定时器</view>
    </view>
    <view class="content" wx:if="{{key==2}}">
        <view class="title">防抖节流</view>
        <view><text
                class="num">节流:</text>多次触发事件时，一段时间内保证只调用一次。以动画为例，人眼中一秒播放超过24张图片就会形成动画，假设有100张图片，我们一秒播放100张过于浪费，一秒播放24张就够了。
        </view>
        <view>
            <text class="num">防抖:</text>
            持续触发事件后，时间段内没有再触发事件，才调用一次。以坐电梯为例，电梯10s运行一次。如果快要运行时进来一个人，则重新计时。
        </view>
    </view>
    <view wx:if="{{key==3}}">
        <view class="content">
            <view class="title">浅拷贝</view>
            <view> <text class="num">1)</text> concat()</view>
            <view> <text class="num">2)</text>Object.assign()</view>
            <view> <text class="num">3)</text>slice()</view>
            <view> <text class="num">4)</text>手写</view>
            <image src="../../img/qcopy.png"></image>
        </view>
        <view class="content">
            <view class="title">深拷贝</view>
            <view> <text class="num">1)</text>JSON.stringfy(JSON.parse())-上面的方法不能解决循环引用，也不能显示函数或undefined</view>
            <view> <text class="num">2)</text>手写深拷贝</view>
            <image src="../../img/copy.png"></image>
        </view>
    </view>
    <view class="content" wx:if="{{key==6}}">
        <view class="title">es6的class的es5的类有什么区别</view>
        <view><text class="num">1)</text>es6中 class内部定义的方法都是不可枚举的 </view>
        <view><text class="num">2)</text>es6中 class必须用new调用 </view>
        <view><text class="num">3)</text>es6中 class不存在变量提升 </view>
        <view><text class="num">4)</text>es6中 class默认使用严格模式</view>
        <view><text class="num">5)</text>es6中 class子类必须在父类的构造函数中调用super(),才有this对象；而es5是先有子类的this，再调用父类的方法应用再在this上面
        </view>
    </view>
    <view wx:if="{{key==7}}">
        <view class="content">
            <view class="title">使用ES6的Set</view>
            <image mode="aspectFit" class="qc1" src="../../img/qc1.png"></image>
        </view>
        <view class="content">
            <view class="title">filter+indexOf()判断，如果数字不是第一次出现则被过滤</view>
            <image mode="aspectFit" class="qc2" src="../../img/qc2.png"></image>
        </view>
        <view class="content">
            <view class="title">双重for循环</view>
            <image mode="aspectFit" class="qc3" src="../../img/qc3.png"></image>
        </view>
        <view class="content">
            <view class="title">哈希表</view>
            <image mode="aspectFit" class="qc2" src="../../img/qc4.png"></image>
        </view>
        <view class="content">
            <view class="title">sort排序，相同的数字会排在相邻n个位置</view>
            <image mode="aspectFit" class="qc3" src="../../img/qc5.png"></image>
        </view>
    </view>
</view>